#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(object):
  def get(self, path):
    """
    Parameters:
     - path
    """
    pass

  def list_branches(self, path):
    """
    Parameters:
     - path
    """
    pass

  def list_tags(self, path):
    """
    Parameters:
     - path
    """
    pass

  def format_patch(self, path, ref, from_ref):
    """
    Parameters:
     - path
     - ref
     - from_ref
    """
    pass

  def detect_renamed(self, path, ref):
    """
    Parameters:
     - path
     - ref
    """
    pass

  def commit(self, path, branch, parent_ref, author_name, author_email, message, reflog, data):
    """
    Parameters:
     - path
     - branch
     - parent_ref
     - author_name
     - author_email
     - message
     - reflog
     - data
    """
    pass

  def resolve_commit(self, path, version):
    """
    Parameters:
     - path
     - version
    """
    pass

  def resolve_type(self, path, version):
    """
    Parameters:
     - path
     - version
    """
    pass

  def create_branch(self, path, name, ref, force):
    """
    Parameters:
     - path
     - name
     - ref
     - force
    """
    pass

  def clone_to(self, path, to_path, is_bare, branch, is_mirror, env):
    """
    Parameters:
     - path
     - to_path
     - is_bare
     - branch
     - is_mirror
     - env
    """
    pass

  def mirror(self, url, to_path, is_bare, branch, env):
    """
    Parameters:
     - url
     - to_path
     - is_bare
     - branch
     - env
    """
    pass

  def init(self, to_path, work_path, is_bare):
    """
    Parameters:
     - to_path
     - work_path
     - is_bare
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def get(self, path):
    """
    Parameters:
     - path
    """
    self.send_get(path)
    return self.recv_get()

  def send_get(self, path):
    self._oprot.writeMessageBegin('get', TMessageType.CALL, self._seqid)
    args = get_args()
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get failed: unknown result");

  def list_branches(self, path):
    """
    Parameters:
     - path
    """
    self.send_list_branches(path)
    return self.recv_list_branches()

  def send_list_branches(self, path):
    self._oprot.writeMessageBegin('list_branches', TMessageType.CALL, self._seqid)
    args = list_branches_args()
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_list_branches(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = list_branches_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    raise TApplicationException(TApplicationException.MISSING_RESULT, "list_branches failed: unknown result");

  def list_tags(self, path):
    """
    Parameters:
     - path
    """
    self.send_list_tags(path)
    return self.recv_list_tags()

  def send_list_tags(self, path):
    self._oprot.writeMessageBegin('list_tags', TMessageType.CALL, self._seqid)
    args = list_tags_args()
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_list_tags(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = list_tags_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    raise TApplicationException(TApplicationException.MISSING_RESULT, "list_tags failed: unknown result");

  def format_patch(self, path, ref, from_ref):
    """
    Parameters:
     - path
     - ref
     - from_ref
    """
    self.send_format_patch(path, ref, from_ref)
    return self.recv_format_patch()

  def send_format_patch(self, path, ref, from_ref):
    self._oprot.writeMessageBegin('format_patch', TMessageType.CALL, self._seqid)
    args = format_patch_args()
    args.path = path
    args.ref = ref
    args.from_ref = from_ref
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_format_patch(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = format_patch_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    raise TApplicationException(TApplicationException.MISSING_RESULT, "format_patch failed: unknown result");

  def detect_renamed(self, path, ref):
    """
    Parameters:
     - path
     - ref
    """
    self.send_detect_renamed(path, ref)
    return self.recv_detect_renamed()

  def send_detect_renamed(self, path, ref):
    self._oprot.writeMessageBegin('detect_renamed', TMessageType.CALL, self._seqid)
    args = detect_renamed_args()
    args.path = path
    args.ref = ref
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_detect_renamed(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = detect_renamed_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    raise TApplicationException(TApplicationException.MISSING_RESULT, "detect_renamed failed: unknown result");

  def commit(self, path, branch, parent_ref, author_name, author_email, message, reflog, data):
    """
    Parameters:
     - path
     - branch
     - parent_ref
     - author_name
     - author_email
     - message
     - reflog
     - data
    """
    self.send_commit(path, branch, parent_ref, author_name, author_email, message, reflog, data)
    return self.recv_commit()

  def send_commit(self, path, branch, parent_ref, author_name, author_email, message, reflog, data):
    self._oprot.writeMessageBegin('commit', TMessageType.CALL, self._seqid)
    args = commit_args()
    args.path = path
    args.branch = branch
    args.parent_ref = parent_ref
    args.author_name = author_name
    args.author_email = author_email
    args.message = message
    args.reflog = reflog
    args.data = data
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_commit(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = commit_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    raise TApplicationException(TApplicationException.MISSING_RESULT, "commit failed: unknown result");

  def resolve_commit(self, path, version):
    """
    Parameters:
     - path
     - version
    """
    self.send_resolve_commit(path, version)
    return self.recv_resolve_commit()

  def send_resolve_commit(self, path, version):
    self._oprot.writeMessageBegin('resolve_commit', TMessageType.CALL, self._seqid)
    args = resolve_commit_args()
    args.path = path
    args.version = version
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_resolve_commit(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = resolve_commit_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    raise TApplicationException(TApplicationException.MISSING_RESULT, "resolve_commit failed: unknown result");

  def resolve_type(self, path, version):
    """
    Parameters:
     - path
     - version
    """
    self.send_resolve_type(path, version)
    return self.recv_resolve_type()

  def send_resolve_type(self, path, version):
    self._oprot.writeMessageBegin('resolve_type', TMessageType.CALL, self._seqid)
    args = resolve_type_args()
    args.path = path
    args.version = version
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_resolve_type(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = resolve_type_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    raise TApplicationException(TApplicationException.MISSING_RESULT, "resolve_type failed: unknown result");

  def create_branch(self, path, name, ref, force):
    """
    Parameters:
     - path
     - name
     - ref
     - force
    """
    self.send_create_branch(path, name, ref, force)
    return self.recv_create_branch()

  def send_create_branch(self, path, name, ref, force):
    self._oprot.writeMessageBegin('create_branch', TMessageType.CALL, self._seqid)
    args = create_branch_args()
    args.path = path
    args.name = name
    args.ref = ref
    args.force = force
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_branch(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_branch_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_branch failed: unknown result");

  def clone_to(self, path, to_path, is_bare, branch, is_mirror, env):
    """
    Parameters:
     - path
     - to_path
     - is_bare
     - branch
     - is_mirror
     - env
    """
    self.send_clone_to(path, to_path, is_bare, branch, is_mirror, env)
    return self.recv_clone_to()

  def send_clone_to(self, path, to_path, is_bare, branch, is_mirror, env):
    self._oprot.writeMessageBegin('clone_to', TMessageType.CALL, self._seqid)
    args = clone_to_args()
    args.path = path
    args.to_path = to_path
    args.is_bare = is_bare
    args.branch = branch
    args.is_mirror = is_mirror
    args.env = env
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clone_to(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = clone_to_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    raise TApplicationException(TApplicationException.MISSING_RESULT, "clone_to failed: unknown result");

  def mirror(self, url, to_path, is_bare, branch, env):
    """
    Parameters:
     - url
     - to_path
     - is_bare
     - branch
     - env
    """
    self.send_mirror(url, to_path, is_bare, branch, env)
    return self.recv_mirror()

  def send_mirror(self, url, to_path, is_bare, branch, env):
    self._oprot.writeMessageBegin('mirror', TMessageType.CALL, self._seqid)
    args = mirror_args()
    args.url = url
    args.to_path = to_path
    args.is_bare = is_bare
    args.branch = branch
    args.env = env
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_mirror(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = mirror_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    raise TApplicationException(TApplicationException.MISSING_RESULT, "mirror failed: unknown result");

  def init(self, to_path, work_path, is_bare):
    """
    Parameters:
     - to_path
     - work_path
     - is_bare
    """
    self.send_init(to_path, work_path, is_bare)
    return self.recv_init()

  def send_init(self, to_path, work_path, is_bare):
    self._oprot.writeMessageBegin('init', TMessageType.CALL, self._seqid)
    args = init_args()
    args.to_path = to_path
    args.work_path = work_path
    args.is_bare = is_bare
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_init(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = init_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    raise TApplicationException(TApplicationException.MISSING_RESULT, "init failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["get"] = Processor.process_get
    self._processMap["list_branches"] = Processor.process_list_branches
    self._processMap["list_tags"] = Processor.process_list_tags
    self._processMap["format_patch"] = Processor.process_format_patch
    self._processMap["detect_renamed"] = Processor.process_detect_renamed
    self._processMap["commit"] = Processor.process_commit
    self._processMap["resolve_commit"] = Processor.process_resolve_commit
    self._processMap["resolve_type"] = Processor.process_resolve_type
    self._processMap["create_branch"] = Processor.process_create_branch
    self._processMap["clone_to"] = Processor.process_clone_to
    self._processMap["mirror"] = Processor.process_mirror
    self._processMap["init"] = Processor.process_init

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_get(self, seqid, iprot, oprot):
    args = get_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_result()
    try:
      result.success = self._handler.get(args.path)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    oprot.writeMessageBegin("get", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_list_branches(self, seqid, iprot, oprot):
    args = list_branches_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = list_branches_result()
    try:
      result.success = self._handler.list_branches(args.path)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    oprot.writeMessageBegin("list_branches", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_list_tags(self, seqid, iprot, oprot):
    args = list_tags_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = list_tags_result()
    try:
      result.success = self._handler.list_tags(args.path)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    oprot.writeMessageBegin("list_tags", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_format_patch(self, seqid, iprot, oprot):
    args = format_patch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = format_patch_result()
    try:
      result.success = self._handler.format_patch(args.path, args.ref, args.from_ref)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    oprot.writeMessageBegin("format_patch", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_detect_renamed(self, seqid, iprot, oprot):
    args = detect_renamed_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = detect_renamed_result()
    try:
      result.success = self._handler.detect_renamed(args.path, args.ref)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    oprot.writeMessageBegin("detect_renamed", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_commit(self, seqid, iprot, oprot):
    args = commit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = commit_result()
    try:
      result.success = self._handler.commit(args.path, args.branch, args.parent_ref, args.author_name, args.author_email, args.message, args.reflog, args.data)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    oprot.writeMessageBegin("commit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_resolve_commit(self, seqid, iprot, oprot):
    args = resolve_commit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = resolve_commit_result()
    try:
      result.success = self._handler.resolve_commit(args.path, args.version)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    oprot.writeMessageBegin("resolve_commit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_resolve_type(self, seqid, iprot, oprot):
    args = resolve_type_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = resolve_type_result()
    try:
      result.success = self._handler.resolve_type(args.path, args.version)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    oprot.writeMessageBegin("resolve_type", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_branch(self, seqid, iprot, oprot):
    args = create_branch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_branch_result()
    try:
      result.success = self._handler.create_branch(args.path, args.name, args.ref, args.force)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    oprot.writeMessageBegin("create_branch", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clone_to(self, seqid, iprot, oprot):
    args = clone_to_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clone_to_result()
    try:
      result.success = self._handler.clone_to(args.path, args.to_path, args.is_bare, args.branch, args.is_mirror, args.env)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    oprot.writeMessageBegin("clone_to", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_mirror(self, seqid, iprot, oprot):
    args = mirror_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = mirror_result()
    try:
      result.success = self._handler.mirror(args.url, args.to_path, args.is_bare, args.branch, args.env)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    oprot.writeMessageBegin("mirror", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_init(self, seqid, iprot, oprot):
    args = init_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = init_result()
    try:
      result.success = self._handler.init(args.to_path, args.work_path, args.is_bare)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    oprot.writeMessageBegin("init", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class get_args(object):
  """
  Attributes:
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
  )

  def __init__(self, path=None,):
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_result(object):
  """
  Attributes:
   - success
   - unavailable
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Repository, Repository.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, unavailable=None,):
    self.success = success
    self.unavailable = unavailable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Repository()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_branches_args(object):
  """
  Attributes:
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
  )

  def __init__(self, path=None,):
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_branches_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_branches_result(object):
  """
  Attributes:
   - success
   - unavailable
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, unavailable=None,):
    self.success = success
    self.unavailable = unavailable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString();
            self.success.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_branches_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter6 in self.success:
        oprot.writeString(iter6)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_tags_args(object):
  """
  Attributes:
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
  )

  def __init__(self, path=None,):
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_tags_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_tags_result(object):
  """
  Attributes:
   - success
   - unavailable
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, unavailable=None,):
    self.success = success
    self.unavailable = unavailable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString();
            self.success.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_tags_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter13 in self.success:
        oprot.writeString(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class format_patch_args(object):
  """
  Attributes:
   - path
   - ref
   - from_ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.STRING, 'from_ref', None, None, ), # 3
  )

  def __init__(self, path=None, ref=None, from_ref=None,):
    self.path = path
    self.ref = ref
    self.from_ref = from_ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.from_ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('format_patch_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.from_ref is not None:
      oprot.writeFieldBegin('from_ref', TType.STRING, 3)
      oprot.writeString(self.from_ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class format_patch_result(object):
  """
  Attributes:
   - success
   - unavailable
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, unavailable=None,):
    self.success = success
    self.unavailable = unavailable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('format_patch_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class detect_renamed_args(object):
  """
  Attributes:
   - path
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, path=None, ref=None,):
    self.path = path
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('detect_renamed_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class detect_renamed_result(object):
  """
  Attributes:
   - success
   - unavailable
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, unavailable=None,):
    self.success = success
    self.unavailable = unavailable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin() 
          for _i18 in xrange(_size14):
            _key19 = iprot.readString();
            _val20 = iprot.readString();
            self.success[_key19] = _val20
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('detect_renamed_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter21,viter22 in self.success.items():
        oprot.writeString(kiter21)
        oprot.writeString(viter22)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class commit_args(object):
  """
  Attributes:
   - path
   - branch
   - parent_ref
   - author_name
   - author_email
   - message
   - reflog
   - data
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'branch', None, None, ), # 2
    (3, TType.STRING, 'parent_ref', None, None, ), # 3
    (4, TType.STRING, 'author_name', None, None, ), # 4
    (5, TType.STRING, 'author_email', None, None, ), # 5
    (6, TType.STRING, 'message', None, None, ), # 6
    (7, TType.STRING, 'reflog', None, None, ), # 7
    (8, TType.LIST, 'data', (TType.LIST,(TType.STRING,None)), None, ), # 8
  )

  def __init__(self, path=None, branch=None, parent_ref=None, author_name=None, author_email=None, message=None, reflog=None, data=None,):
    self.path = path
    self.branch = branch
    self.parent_ref = parent_ref
    self.author_name = author_name
    self.author_email = author_email
    self.message = message
    self.reflog = reflog
    self.data = data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.branch = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.parent_ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.author_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.author_email = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.reflog = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.data = []
          (_etype26, _size23) = iprot.readListBegin()
          for _i27 in xrange(_size23):
            _elem28 = []
            (_etype32, _size29) = iprot.readListBegin()
            for _i33 in xrange(_size29):
              _elem34 = iprot.readString();
              _elem28.append(_elem34)
            iprot.readListEnd()
            self.data.append(_elem28)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('commit_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.branch is not None:
      oprot.writeFieldBegin('branch', TType.STRING, 2)
      oprot.writeString(self.branch)
      oprot.writeFieldEnd()
    if self.parent_ref is not None:
      oprot.writeFieldBegin('parent_ref', TType.STRING, 3)
      oprot.writeString(self.parent_ref)
      oprot.writeFieldEnd()
    if self.author_name is not None:
      oprot.writeFieldBegin('author_name', TType.STRING, 4)
      oprot.writeString(self.author_name)
      oprot.writeFieldEnd()
    if self.author_email is not None:
      oprot.writeFieldBegin('author_email', TType.STRING, 5)
      oprot.writeString(self.author_email)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 6)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    if self.reflog is not None:
      oprot.writeFieldBegin('reflog', TType.STRING, 7)
      oprot.writeString(self.reflog)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.LIST, 8)
      oprot.writeListBegin(TType.LIST, len(self.data))
      for iter35 in self.data:
        oprot.writeListBegin(TType.STRING, len(iter35))
        for iter36 in iter35:
          oprot.writeString(iter36)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class commit_result(object):
  """
  Attributes:
   - success
   - unavailable
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, unavailable=None,):
    self.success = success
    self.unavailable = unavailable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('commit_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class resolve_commit_args(object):
  """
  Attributes:
   - path
   - version
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'version', None, None, ), # 2
  )

  def __init__(self, path=None, version=None,):
    self.path = path
    self.version = version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.version = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resolve_commit_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.STRING, 2)
      oprot.writeString(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class resolve_commit_result(object):
  """
  Attributes:
   - success
   - unavailable
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, unavailable=None,):
    self.success = success
    self.unavailable = unavailable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resolve_commit_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class resolve_type_args(object):
  """
  Attributes:
   - path
   - version
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'version', None, None, ), # 2
  )

  def __init__(self, path=None, version=None,):
    self.path = path
    self.version = version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.version = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resolve_type_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.STRING, 2)
      oprot.writeString(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class resolve_type_result(object):
  """
  Attributes:
   - success
   - unavailable
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, unavailable=None,):
    self.success = success
    self.unavailable = unavailable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resolve_type_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_branch_args(object):
  """
  Attributes:
   - path
   - name
   - ref
   - force
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.STRING, 'ref', None, None, ), # 3
    (4, TType.BOOL, 'force', None, None, ), # 4
  )

  def __init__(self, path=None, name=None, ref=None, force=None,):
    self.path = path
    self.name = name
    self.ref = ref
    self.force = force

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.force = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_branch_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 3)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.force is not None:
      oprot.writeFieldBegin('force', TType.BOOL, 4)
      oprot.writeBool(self.force)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_branch_result(object):
  """
  Attributes:
   - success
   - unavailable
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, unavailable=None,):
    self.success = success
    self.unavailable = unavailable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_branch_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clone_to_args(object):
  """
  Attributes:
   - path
   - to_path
   - is_bare
   - branch
   - is_mirror
   - env
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'to_path', None, None, ), # 2
    (3, TType.BOOL, 'is_bare', None, None, ), # 3
    (4, TType.STRING, 'branch', None, None, ), # 4
    (5, TType.BOOL, 'is_mirror', None, None, ), # 5
    (6, TType.MAP, 'env', (TType.STRING,None,TType.STRING,None), None, ), # 6
  )

  def __init__(self, path=None, to_path=None, is_bare=None, branch=None, is_mirror=None, env=None,):
    self.path = path
    self.to_path = to_path
    self.is_bare = is_bare
    self.branch = branch
    self.is_mirror = is_mirror
    self.env = env

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.to_path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_bare = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.branch = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.is_mirror = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.env = {}
          (_ktype38, _vtype39, _size37 ) = iprot.readMapBegin() 
          for _i41 in xrange(_size37):
            _key42 = iprot.readString();
            _val43 = iprot.readString();
            self.env[_key42] = _val43
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clone_to_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.to_path is not None:
      oprot.writeFieldBegin('to_path', TType.STRING, 2)
      oprot.writeString(self.to_path)
      oprot.writeFieldEnd()
    if self.is_bare is not None:
      oprot.writeFieldBegin('is_bare', TType.BOOL, 3)
      oprot.writeBool(self.is_bare)
      oprot.writeFieldEnd()
    if self.branch is not None:
      oprot.writeFieldBegin('branch', TType.STRING, 4)
      oprot.writeString(self.branch)
      oprot.writeFieldEnd()
    if self.is_mirror is not None:
      oprot.writeFieldBegin('is_mirror', TType.BOOL, 5)
      oprot.writeBool(self.is_mirror)
      oprot.writeFieldEnd()
    if self.env is not None:
      oprot.writeFieldBegin('env', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.env))
      for kiter44,viter45 in self.env.items():
        oprot.writeString(kiter44)
        oprot.writeString(viter45)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clone_to_result(object):
  """
  Attributes:
   - success
   - unavailable
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Repository, Repository.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, unavailable=None,):
    self.success = success
    self.unavailable = unavailable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Repository()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clone_to_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mirror_args(object):
  """
  Attributes:
   - url
   - to_path
   - is_bare
   - branch
   - env
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'url', None, None, ), # 1
    (2, TType.STRING, 'to_path', None, None, ), # 2
    (3, TType.BOOL, 'is_bare', None, None, ), # 3
    (4, TType.STRING, 'branch', None, None, ), # 4
    (5, TType.MAP, 'env', (TType.STRING,None,TType.STRING,None), None, ), # 5
  )

  def __init__(self, url=None, to_path=None, is_bare=None, branch=None, env=None,):
    self.url = url
    self.to_path = to_path
    self.is_bare = is_bare
    self.branch = branch
    self.env = env

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.to_path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_bare = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.branch = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.env = {}
          (_ktype47, _vtype48, _size46 ) = iprot.readMapBegin() 
          for _i50 in xrange(_size46):
            _key51 = iprot.readString();
            _val52 = iprot.readString();
            self.env[_key51] = _val52
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mirror_args')
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 1)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.to_path is not None:
      oprot.writeFieldBegin('to_path', TType.STRING, 2)
      oprot.writeString(self.to_path)
      oprot.writeFieldEnd()
    if self.is_bare is not None:
      oprot.writeFieldBegin('is_bare', TType.BOOL, 3)
      oprot.writeBool(self.is_bare)
      oprot.writeFieldEnd()
    if self.branch is not None:
      oprot.writeFieldBegin('branch', TType.STRING, 4)
      oprot.writeString(self.branch)
      oprot.writeFieldEnd()
    if self.env is not None:
      oprot.writeFieldBegin('env', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.env))
      for kiter53,viter54 in self.env.items():
        oprot.writeString(kiter53)
        oprot.writeString(viter54)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mirror_result(object):
  """
  Attributes:
   - success
   - unavailable
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Repository, Repository.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, unavailable=None,):
    self.success = success
    self.unavailable = unavailable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Repository()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mirror_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class init_args(object):
  """
  Attributes:
   - to_path
   - work_path
   - is_bare
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'to_path', None, None, ), # 1
    (2, TType.STRING, 'work_path', None, None, ), # 2
    (3, TType.BOOL, 'is_bare', None, None, ), # 3
  )

  def __init__(self, to_path=None, work_path=None, is_bare=None,):
    self.to_path = to_path
    self.work_path = work_path
    self.is_bare = is_bare

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.to_path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.work_path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_bare = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('init_args')
    if self.to_path is not None:
      oprot.writeFieldBegin('to_path', TType.STRING, 1)
      oprot.writeString(self.to_path)
      oprot.writeFieldEnd()
    if self.work_path is not None:
      oprot.writeFieldBegin('work_path', TType.STRING, 2)
      oprot.writeString(self.work_path)
      oprot.writeFieldEnd()
    if self.is_bare is not None:
      oprot.writeFieldBegin('is_bare', TType.BOOL, 3)
      oprot.writeBool(self.is_bare)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class init_result(object):
  """
  Attributes:
   - success
   - unavailable
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Repository, Repository.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
  )

  def __init__(self, success=None, unavailable=None,):
    self.success = success
    self.unavailable = unavailable

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Repository()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('init_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
