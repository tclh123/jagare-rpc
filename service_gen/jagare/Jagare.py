#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface(object):
  def get(self, path):
    """
    Parameters:
     - path
    """
    pass

  def list_branches(self, path):
    """
    Parameters:
     - path
    """
    pass

  def list_remotes(self, path):
    """
    Parameters:
     - path
    """
    pass

  def list_tags(self, path):
    """
    Parameters:
     - path
    """
    pass

  def show(self, path, ref):
    """
    Parameters:
     - path
     - ref
    """
    pass

  def ls_tree(self, path, ref, req_path, recursive, with_size, with_commit, name_only):
    """
    Parameters:
     - path
     - ref
     - req_path
     - recursive
     - with_size
     - with_commit
     - name_only
    """
    pass

  def rev_list(self, path, to_ref, from_ref, file_path, skip, max_count, author, query, first_parent, since, no_merges):
    """
    Parameters:
     - path
     - to_ref
     - from_ref
     - file_path
     - skip
     - max_count
     - author
     - query
     - first_parent
     - since
     - no_merges
    """
    pass

  def blame(self, path, ref, req_path, lineno):
    """
    Parameters:
     - path
     - ref
     - req_path
     - lineno
    """
    pass

  def format_patch(self, path, ref, from_ref):
    """
    Parameters:
     - path
     - ref
     - from_ref
    """
    pass

  def detect_renamed(self, path, ref):
    """
    Parameters:
     - path
     - ref
    """
    pass

  def commit(self, path, branch, parent_ref, author_name, author_email, message, reflog, data):
    """
    Parameters:
     - path
     - branch
     - parent_ref
     - author_name
     - author_email
     - message
     - reflog
     - data
    """
    pass

  def diff(self, path, ref, from_ref, ignore_space, flags, context_lines, paths, rename_detection):
    """
    Parameters:
     - path
     - ref
     - from_ref
     - ignore_space
     - flags
     - context_lines
     - paths
     - rename_detection
    """
    pass

  def resolve_commit(self, path, version):
    """
    Parameters:
     - path
     - version
    """
    pass

  def resolve_type(self, path, version):
    """
    Parameters:
     - path
     - version
    """
    pass

  def create_branch(self, path, name, ref, force):
    """
    Parameters:
     - path
     - name
     - ref
     - force
    """
    pass

  def delete_branch(self, path, name):
    """
    Parameters:
     - path
     - name
    """
    pass

  def clone_to(self, path, to_path, is_bare, branch, is_mirror, env):
    """
    Parameters:
     - path
     - to_path
     - is_bare
     - branch
     - is_mirror
     - env
    """
    pass

  def mirror(self, url, to_path, is_bare, branch, env):
    """
    Parameters:
     - url
     - to_path
     - is_bare
     - branch
     - env
    """
    pass

  def init(self, to_path, work_path, is_bare):
    """
    Parameters:
     - to_path
     - work_path
     - is_bare
    """
    pass

  def list_references(self, path):
    """
    Parameters:
     - path
    """
    pass

  def add_remote(self, path, name, url):
    """
    Parameters:
     - path
     - name
     - url
    """
    pass

  def update_ref(self, path, ref, newvalue):
    """
    Parameters:
     - path
     - ref
     - newvalue
    """
    pass

  def update_head(self, path, branch_name):
    """
    Parameters:
     - path
     - branch_name
    """
    pass

  def sha(self, path, rev):
    """
    Parameters:
     - path
     - rev
    """
    pass

  def merge_base(self, path, to_sha, from_sha):
    """
    Parameters:
     - path
     - to_sha
     - from_sha
    """
    pass

  def fetch_all(self, path):
    """
    Parameters:
     - path
    """
    pass

  def fetch(self, path, name):
    """
    Parameters:
     - path
     - name
    """
    pass

  def merge(self, path, ref, msg, commit_msg, no_ff, env):
    """
    Parameters:
     - path
     - ref
     - msg
     - commit_msg
     - no_ff
     - env
    """
    pass

  def merge_tree(self, path, ours, theirs):
    """
    Parameters:
     - path
     - ours
     - theirs
    """
    pass

  def merge_head(self, path, ref):
    """
    Parameters:
     - path
     - ref
    """
    pass

  def merge_commits(self, path, ours, theirs):
    """
    Parameters:
     - path
     - ours
     - theirs
    """
    pass

  def push(self, path, remote, ref, env):
    """
    Parameters:
     - path
     - remote
     - ref
     - env
    """
    pass

  def archive(self, path, prefix, ref):
    """
    Parameters:
     - path
     - prefix
     - ref
    """
    pass


class Client(Iface):
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def get(self, path):
    """
    Parameters:
     - path
    """
    self.send_get(path)
    return self.recv_get()

  def send_get(self, path):
    self._oprot.writeMessageBegin('get', TMessageType.CALL, self._seqid)
    args = get_args()
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_get(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = get_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "get failed: unknown result");

  def list_branches(self, path):
    """
    Parameters:
     - path
    """
    self.send_list_branches(path)
    return self.recv_list_branches()

  def send_list_branches(self, path):
    self._oprot.writeMessageBegin('list_branches', TMessageType.CALL, self._seqid)
    args = list_branches_args()
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_list_branches(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = list_branches_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "list_branches failed: unknown result");

  def list_remotes(self, path):
    """
    Parameters:
     - path
    """
    self.send_list_remotes(path)
    return self.recv_list_remotes()

  def send_list_remotes(self, path):
    self._oprot.writeMessageBegin('list_remotes', TMessageType.CALL, self._seqid)
    args = list_remotes_args()
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_list_remotes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = list_remotes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "list_remotes failed: unknown result");

  def list_tags(self, path):
    """
    Parameters:
     - path
    """
    self.send_list_tags(path)
    return self.recv_list_tags()

  def send_list_tags(self, path):
    self._oprot.writeMessageBegin('list_tags', TMessageType.CALL, self._seqid)
    args = list_tags_args()
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_list_tags(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = list_tags_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "list_tags failed: unknown result");

  def show(self, path, ref):
    """
    Parameters:
     - path
     - ref
    """
    self.send_show(path, ref)
    return self.recv_show()

  def send_show(self, path, ref):
    self._oprot.writeMessageBegin('show', TMessageType.CALL, self._seqid)
    args = show_args()
    args.path = path
    args.ref = ref
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_show(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = show_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "show failed: unknown result");

  def ls_tree(self, path, ref, req_path, recursive, with_size, with_commit, name_only):
    """
    Parameters:
     - path
     - ref
     - req_path
     - recursive
     - with_size
     - with_commit
     - name_only
    """
    self.send_ls_tree(path, ref, req_path, recursive, with_size, with_commit, name_only)
    return self.recv_ls_tree()

  def send_ls_tree(self, path, ref, req_path, recursive, with_size, with_commit, name_only):
    self._oprot.writeMessageBegin('ls_tree', TMessageType.CALL, self._seqid)
    args = ls_tree_args()
    args.path = path
    args.ref = ref
    args.req_path = req_path
    args.recursive = recursive
    args.with_size = with_size
    args.with_commit = with_commit
    args.name_only = name_only
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_ls_tree(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = ls_tree_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "ls_tree failed: unknown result");

  def rev_list(self, path, to_ref, from_ref, file_path, skip, max_count, author, query, first_parent, since, no_merges):
    """
    Parameters:
     - path
     - to_ref
     - from_ref
     - file_path
     - skip
     - max_count
     - author
     - query
     - first_parent
     - since
     - no_merges
    """
    self.send_rev_list(path, to_ref, from_ref, file_path, skip, max_count, author, query, first_parent, since, no_merges)
    return self.recv_rev_list()

  def send_rev_list(self, path, to_ref, from_ref, file_path, skip, max_count, author, query, first_parent, since, no_merges):
    self._oprot.writeMessageBegin('rev_list', TMessageType.CALL, self._seqid)
    args = rev_list_args()
    args.path = path
    args.to_ref = to_ref
    args.from_ref = from_ref
    args.file_path = file_path
    args.skip = skip
    args.max_count = max_count
    args.author = author
    args.query = query
    args.first_parent = first_parent
    args.since = since
    args.no_merges = no_merges
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_rev_list(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = rev_list_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "rev_list failed: unknown result");

  def blame(self, path, ref, req_path, lineno):
    """
    Parameters:
     - path
     - ref
     - req_path
     - lineno
    """
    self.send_blame(path, ref, req_path, lineno)
    return self.recv_blame()

  def send_blame(self, path, ref, req_path, lineno):
    self._oprot.writeMessageBegin('blame', TMessageType.CALL, self._seqid)
    args = blame_args()
    args.path = path
    args.ref = ref
    args.req_path = req_path
    args.lineno = lineno
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_blame(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = blame_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "blame failed: unknown result");

  def format_patch(self, path, ref, from_ref):
    """
    Parameters:
     - path
     - ref
     - from_ref
    """
    self.send_format_patch(path, ref, from_ref)
    return self.recv_format_patch()

  def send_format_patch(self, path, ref, from_ref):
    self._oprot.writeMessageBegin('format_patch', TMessageType.CALL, self._seqid)
    args = format_patch_args()
    args.path = path
    args.ref = ref
    args.from_ref = from_ref
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_format_patch(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = format_patch_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "format_patch failed: unknown result");

  def detect_renamed(self, path, ref):
    """
    Parameters:
     - path
     - ref
    """
    self.send_detect_renamed(path, ref)
    return self.recv_detect_renamed()

  def send_detect_renamed(self, path, ref):
    self._oprot.writeMessageBegin('detect_renamed', TMessageType.CALL, self._seqid)
    args = detect_renamed_args()
    args.path = path
    args.ref = ref
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_detect_renamed(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = detect_renamed_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "detect_renamed failed: unknown result");

  def commit(self, path, branch, parent_ref, author_name, author_email, message, reflog, data):
    """
    Parameters:
     - path
     - branch
     - parent_ref
     - author_name
     - author_email
     - message
     - reflog
     - data
    """
    self.send_commit(path, branch, parent_ref, author_name, author_email, message, reflog, data)
    return self.recv_commit()

  def send_commit(self, path, branch, parent_ref, author_name, author_email, message, reflog, data):
    self._oprot.writeMessageBegin('commit', TMessageType.CALL, self._seqid)
    args = commit_args()
    args.path = path
    args.branch = branch
    args.parent_ref = parent_ref
    args.author_name = author_name
    args.author_email = author_email
    args.message = message
    args.reflog = reflog
    args.data = data
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_commit(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = commit_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "commit failed: unknown result");

  def diff(self, path, ref, from_ref, ignore_space, flags, context_lines, paths, rename_detection):
    """
    Parameters:
     - path
     - ref
     - from_ref
     - ignore_space
     - flags
     - context_lines
     - paths
     - rename_detection
    """
    self.send_diff(path, ref, from_ref, ignore_space, flags, context_lines, paths, rename_detection)
    return self.recv_diff()

  def send_diff(self, path, ref, from_ref, ignore_space, flags, context_lines, paths, rename_detection):
    self._oprot.writeMessageBegin('diff', TMessageType.CALL, self._seqid)
    args = diff_args()
    args.path = path
    args.ref = ref
    args.from_ref = from_ref
    args.ignore_space = ignore_space
    args.flags = flags
    args.context_lines = context_lines
    args.paths = paths
    args.rename_detection = rename_detection
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_diff(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = diff_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "diff failed: unknown result");

  def resolve_commit(self, path, version):
    """
    Parameters:
     - path
     - version
    """
    self.send_resolve_commit(path, version)
    return self.recv_resolve_commit()

  def send_resolve_commit(self, path, version):
    self._oprot.writeMessageBegin('resolve_commit', TMessageType.CALL, self._seqid)
    args = resolve_commit_args()
    args.path = path
    args.version = version
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_resolve_commit(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = resolve_commit_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "resolve_commit failed: unknown result");

  def resolve_type(self, path, version):
    """
    Parameters:
     - path
     - version
    """
    self.send_resolve_type(path, version)
    return self.recv_resolve_type()

  def send_resolve_type(self, path, version):
    self._oprot.writeMessageBegin('resolve_type', TMessageType.CALL, self._seqid)
    args = resolve_type_args()
    args.path = path
    args.version = version
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_resolve_type(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = resolve_type_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "resolve_type failed: unknown result");

  def create_branch(self, path, name, ref, force):
    """
    Parameters:
     - path
     - name
     - ref
     - force
    """
    self.send_create_branch(path, name, ref, force)
    return self.recv_create_branch()

  def send_create_branch(self, path, name, ref, force):
    self._oprot.writeMessageBegin('create_branch', TMessageType.CALL, self._seqid)
    args = create_branch_args()
    args.path = path
    args.name = name
    args.ref = ref
    args.force = force
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_create_branch(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = create_branch_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "create_branch failed: unknown result");

  def delete_branch(self, path, name):
    """
    Parameters:
     - path
     - name
    """
    self.send_delete_branch(path, name)
    return self.recv_delete_branch()

  def send_delete_branch(self, path, name):
    self._oprot.writeMessageBegin('delete_branch', TMessageType.CALL, self._seqid)
    args = delete_branch_args()
    args.path = path
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_delete_branch(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = delete_branch_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_branch failed: unknown result");

  def clone_to(self, path, to_path, is_bare, branch, is_mirror, env):
    """
    Parameters:
     - path
     - to_path
     - is_bare
     - branch
     - is_mirror
     - env
    """
    self.send_clone_to(path, to_path, is_bare, branch, is_mirror, env)
    return self.recv_clone_to()

  def send_clone_to(self, path, to_path, is_bare, branch, is_mirror, env):
    self._oprot.writeMessageBegin('clone_to', TMessageType.CALL, self._seqid)
    args = clone_to_args()
    args.path = path
    args.to_path = to_path
    args.is_bare = is_bare
    args.branch = branch
    args.is_mirror = is_mirror
    args.env = env
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_clone_to(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = clone_to_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "clone_to failed: unknown result");

  def mirror(self, url, to_path, is_bare, branch, env):
    """
    Parameters:
     - url
     - to_path
     - is_bare
     - branch
     - env
    """
    self.send_mirror(url, to_path, is_bare, branch, env)
    return self.recv_mirror()

  def send_mirror(self, url, to_path, is_bare, branch, env):
    self._oprot.writeMessageBegin('mirror', TMessageType.CALL, self._seqid)
    args = mirror_args()
    args.url = url
    args.to_path = to_path
    args.is_bare = is_bare
    args.branch = branch
    args.env = env
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_mirror(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = mirror_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "mirror failed: unknown result");

  def init(self, to_path, work_path, is_bare):
    """
    Parameters:
     - to_path
     - work_path
     - is_bare
    """
    self.send_init(to_path, work_path, is_bare)
    return self.recv_init()

  def send_init(self, to_path, work_path, is_bare):
    self._oprot.writeMessageBegin('init', TMessageType.CALL, self._seqid)
    args = init_args()
    args.to_path = to_path
    args.work_path = work_path
    args.is_bare = is_bare
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_init(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = init_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "init failed: unknown result");

  def list_references(self, path):
    """
    Parameters:
     - path
    """
    self.send_list_references(path)
    return self.recv_list_references()

  def send_list_references(self, path):
    self._oprot.writeMessageBegin('list_references', TMessageType.CALL, self._seqid)
    args = list_references_args()
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_list_references(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = list_references_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "list_references failed: unknown result");

  def add_remote(self, path, name, url):
    """
    Parameters:
     - path
     - name
     - url
    """
    self.send_add_remote(path, name, url)
    return self.recv_add_remote()

  def send_add_remote(self, path, name, url):
    self._oprot.writeMessageBegin('add_remote', TMessageType.CALL, self._seqid)
    args = add_remote_args()
    args.path = path
    args.name = name
    args.url = url
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_add_remote(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = add_remote_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "add_remote failed: unknown result");

  def update_ref(self, path, ref, newvalue):
    """
    Parameters:
     - path
     - ref
     - newvalue
    """
    self.send_update_ref(path, ref, newvalue)
    return self.recv_update_ref()

  def send_update_ref(self, path, ref, newvalue):
    self._oprot.writeMessageBegin('update_ref', TMessageType.CALL, self._seqid)
    args = update_ref_args()
    args.path = path
    args.ref = ref
    args.newvalue = newvalue
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_ref(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = update_ref_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "update_ref failed: unknown result");

  def update_head(self, path, branch_name):
    """
    Parameters:
     - path
     - branch_name
    """
    self.send_update_head(path, branch_name)
    return self.recv_update_head()

  def send_update_head(self, path, branch_name):
    self._oprot.writeMessageBegin('update_head', TMessageType.CALL, self._seqid)
    args = update_head_args()
    args.path = path
    args.branch_name = branch_name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_update_head(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = update_head_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "update_head failed: unknown result");

  def sha(self, path, rev):
    """
    Parameters:
     - path
     - rev
    """
    self.send_sha(path, rev)
    return self.recv_sha()

  def send_sha(self, path, rev):
    self._oprot.writeMessageBegin('sha', TMessageType.CALL, self._seqid)
    args = sha_args()
    args.path = path
    args.rev = rev
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_sha(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = sha_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "sha failed: unknown result");

  def merge_base(self, path, to_sha, from_sha):
    """
    Parameters:
     - path
     - to_sha
     - from_sha
    """
    self.send_merge_base(path, to_sha, from_sha)
    return self.recv_merge_base()

  def send_merge_base(self, path, to_sha, from_sha):
    self._oprot.writeMessageBegin('merge_base', TMessageType.CALL, self._seqid)
    args = merge_base_args()
    args.path = path
    args.to_sha = to_sha
    args.from_sha = from_sha
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_merge_base(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = merge_base_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "merge_base failed: unknown result");

  def fetch_all(self, path):
    """
    Parameters:
     - path
    """
    self.send_fetch_all(path)

  def send_fetch_all(self, path):
    self._oprot.writeMessageBegin('fetch_all', TMessageType.CALL, self._seqid)
    args = fetch_all_args()
    args.path = path
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def fetch(self, path, name):
    """
    Parameters:
     - path
     - name
    """
    self.send_fetch(path, name)

  def send_fetch(self, path, name):
    self._oprot.writeMessageBegin('fetch', TMessageType.CALL, self._seqid)
    args = fetch_args()
    args.path = path
    args.name = name
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()
  def merge(self, path, ref, msg, commit_msg, no_ff, env):
    """
    Parameters:
     - path
     - ref
     - msg
     - commit_msg
     - no_ff
     - env
    """
    self.send_merge(path, ref, msg, commit_msg, no_ff, env)
    return self.recv_merge()

  def send_merge(self, path, ref, msg, commit_msg, no_ff, env):
    self._oprot.writeMessageBegin('merge', TMessageType.CALL, self._seqid)
    args = merge_args()
    args.path = path
    args.ref = ref
    args.msg = msg
    args.commit_msg = commit_msg
    args.no_ff = no_ff
    args.env = env
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_merge(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = merge_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "merge failed: unknown result");

  def merge_tree(self, path, ours, theirs):
    """
    Parameters:
     - path
     - ours
     - theirs
    """
    self.send_merge_tree(path, ours, theirs)
    return self.recv_merge_tree()

  def send_merge_tree(self, path, ours, theirs):
    self._oprot.writeMessageBegin('merge_tree', TMessageType.CALL, self._seqid)
    args = merge_tree_args()
    args.path = path
    args.ours = ours
    args.theirs = theirs
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_merge_tree(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = merge_tree_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "merge_tree failed: unknown result");

  def merge_head(self, path, ref):
    """
    Parameters:
     - path
     - ref
    """
    self.send_merge_head(path, ref)
    return self.recv_merge_head()

  def send_merge_head(self, path, ref):
    self._oprot.writeMessageBegin('merge_head', TMessageType.CALL, self._seqid)
    args = merge_head_args()
    args.path = path
    args.ref = ref
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_merge_head(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = merge_head_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "merge_head failed: unknown result");

  def merge_commits(self, path, ours, theirs):
    """
    Parameters:
     - path
     - ours
     - theirs
    """
    self.send_merge_commits(path, ours, theirs)
    return self.recv_merge_commits()

  def send_merge_commits(self, path, ours, theirs):
    self._oprot.writeMessageBegin('merge_commits', TMessageType.CALL, self._seqid)
    args = merge_commits_args()
    args.path = path
    args.ours = ours
    args.theirs = theirs
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_merge_commits(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = merge_commits_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "merge_commits failed: unknown result");

  def push(self, path, remote, ref, env):
    """
    Parameters:
     - path
     - remote
     - ref
     - env
    """
    self.send_push(path, remote, ref, env)
    return self.recv_push()

  def send_push(self, path, remote, ref, env):
    self._oprot.writeMessageBegin('push', TMessageType.CALL, self._seqid)
    args = push_args()
    args.path = path
    args.remote = remote
    args.ref = ref
    args.env = env
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_push(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = push_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "push failed: unknown result");

  def archive(self, path, prefix, ref):
    """
    Parameters:
     - path
     - prefix
     - ref
    """
    self.send_archive(path, prefix, ref)
    return self.recv_archive()

  def send_archive(self, path, prefix, ref):
    self._oprot.writeMessageBegin('archive', TMessageType.CALL, self._seqid)
    args = archive_args()
    args.path = path
    args.prefix = prefix
    args.ref = ref
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_archive(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = archive_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.unavailable is not None:
      raise result.unavailable
    if result.none_result is not None:
      raise result.none_result
    raise TApplicationException(TApplicationException.MISSING_RESULT, "archive failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["get"] = Processor.process_get
    self._processMap["list_branches"] = Processor.process_list_branches
    self._processMap["list_remotes"] = Processor.process_list_remotes
    self._processMap["list_tags"] = Processor.process_list_tags
    self._processMap["show"] = Processor.process_show
    self._processMap["ls_tree"] = Processor.process_ls_tree
    self._processMap["rev_list"] = Processor.process_rev_list
    self._processMap["blame"] = Processor.process_blame
    self._processMap["format_patch"] = Processor.process_format_patch
    self._processMap["detect_renamed"] = Processor.process_detect_renamed
    self._processMap["commit"] = Processor.process_commit
    self._processMap["diff"] = Processor.process_diff
    self._processMap["resolve_commit"] = Processor.process_resolve_commit
    self._processMap["resolve_type"] = Processor.process_resolve_type
    self._processMap["create_branch"] = Processor.process_create_branch
    self._processMap["delete_branch"] = Processor.process_delete_branch
    self._processMap["clone_to"] = Processor.process_clone_to
    self._processMap["mirror"] = Processor.process_mirror
    self._processMap["init"] = Processor.process_init
    self._processMap["list_references"] = Processor.process_list_references
    self._processMap["add_remote"] = Processor.process_add_remote
    self._processMap["update_ref"] = Processor.process_update_ref
    self._processMap["update_head"] = Processor.process_update_head
    self._processMap["sha"] = Processor.process_sha
    self._processMap["merge_base"] = Processor.process_merge_base
    self._processMap["fetch_all"] = Processor.process_fetch_all
    self._processMap["fetch"] = Processor.process_fetch
    self._processMap["merge"] = Processor.process_merge
    self._processMap["merge_tree"] = Processor.process_merge_tree
    self._processMap["merge_head"] = Processor.process_merge_head
    self._processMap["merge_commits"] = Processor.process_merge_commits
    self._processMap["push"] = Processor.process_push
    self._processMap["archive"] = Processor.process_archive

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_get(self, seqid, iprot, oprot):
    args = get_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = get_result()
    try:
      result.success = self._handler.get(args.path)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("get", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_list_branches(self, seqid, iprot, oprot):
    args = list_branches_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = list_branches_result()
    try:
      result.success = self._handler.list_branches(args.path)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("list_branches", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_list_remotes(self, seqid, iprot, oprot):
    args = list_remotes_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = list_remotes_result()
    try:
      result.success = self._handler.list_remotes(args.path)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("list_remotes", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_list_tags(self, seqid, iprot, oprot):
    args = list_tags_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = list_tags_result()
    try:
      result.success = self._handler.list_tags(args.path)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("list_tags", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_show(self, seqid, iprot, oprot):
    args = show_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = show_result()
    try:
      result.success = self._handler.show(args.path, args.ref)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("show", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_ls_tree(self, seqid, iprot, oprot):
    args = ls_tree_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = ls_tree_result()
    try:
      result.success = self._handler.ls_tree(args.path, args.ref, args.req_path, args.recursive, args.with_size, args.with_commit, args.name_only)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("ls_tree", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_rev_list(self, seqid, iprot, oprot):
    args = rev_list_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = rev_list_result()
    try:
      result.success = self._handler.rev_list(args.path, args.to_ref, args.from_ref, args.file_path, args.skip, args.max_count, args.author, args.query, args.first_parent, args.since, args.no_merges)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("rev_list", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_blame(self, seqid, iprot, oprot):
    args = blame_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = blame_result()
    try:
      result.success = self._handler.blame(args.path, args.ref, args.req_path, args.lineno)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("blame", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_format_patch(self, seqid, iprot, oprot):
    args = format_patch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = format_patch_result()
    try:
      result.success = self._handler.format_patch(args.path, args.ref, args.from_ref)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("format_patch", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_detect_renamed(self, seqid, iprot, oprot):
    args = detect_renamed_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = detect_renamed_result()
    try:
      result.success = self._handler.detect_renamed(args.path, args.ref)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("detect_renamed", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_commit(self, seqid, iprot, oprot):
    args = commit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = commit_result()
    try:
      result.success = self._handler.commit(args.path, args.branch, args.parent_ref, args.author_name, args.author_email, args.message, args.reflog, args.data)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("commit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_diff(self, seqid, iprot, oprot):
    args = diff_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = diff_result()
    try:
      result.success = self._handler.diff(args.path, args.ref, args.from_ref, args.ignore_space, args.flags, args.context_lines, args.paths, args.rename_detection)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("diff", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_resolve_commit(self, seqid, iprot, oprot):
    args = resolve_commit_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = resolve_commit_result()
    try:
      result.success = self._handler.resolve_commit(args.path, args.version)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("resolve_commit", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_resolve_type(self, seqid, iprot, oprot):
    args = resolve_type_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = resolve_type_result()
    try:
      result.success = self._handler.resolve_type(args.path, args.version)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("resolve_type", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_create_branch(self, seqid, iprot, oprot):
    args = create_branch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = create_branch_result()
    try:
      result.success = self._handler.create_branch(args.path, args.name, args.ref, args.force)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("create_branch", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_delete_branch(self, seqid, iprot, oprot):
    args = delete_branch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = delete_branch_result()
    try:
      result.success = self._handler.delete_branch(args.path, args.name)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("delete_branch", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_clone_to(self, seqid, iprot, oprot):
    args = clone_to_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = clone_to_result()
    try:
      result.success = self._handler.clone_to(args.path, args.to_path, args.is_bare, args.branch, args.is_mirror, args.env)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("clone_to", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_mirror(self, seqid, iprot, oprot):
    args = mirror_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = mirror_result()
    try:
      result.success = self._handler.mirror(args.url, args.to_path, args.is_bare, args.branch, args.env)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("mirror", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_init(self, seqid, iprot, oprot):
    args = init_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = init_result()
    try:
      result.success = self._handler.init(args.to_path, args.work_path, args.is_bare)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("init", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_list_references(self, seqid, iprot, oprot):
    args = list_references_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = list_references_result()
    try:
      result.success = self._handler.list_references(args.path)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("list_references", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_add_remote(self, seqid, iprot, oprot):
    args = add_remote_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = add_remote_result()
    try:
      result.success = self._handler.add_remote(args.path, args.name, args.url)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("add_remote", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_ref(self, seqid, iprot, oprot):
    args = update_ref_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_ref_result()
    try:
      result.success = self._handler.update_ref(args.path, args.ref, args.newvalue)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("update_ref", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_update_head(self, seqid, iprot, oprot):
    args = update_head_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = update_head_result()
    try:
      result.success = self._handler.update_head(args.path, args.branch_name)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("update_head", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_sha(self, seqid, iprot, oprot):
    args = sha_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = sha_result()
    try:
      result.success = self._handler.sha(args.path, args.rev)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("sha", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_merge_base(self, seqid, iprot, oprot):
    args = merge_base_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = merge_base_result()
    try:
      result.success = self._handler.merge_base(args.path, args.to_sha, args.from_sha)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("merge_base", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_fetch_all(self, seqid, iprot, oprot):
    args = fetch_all_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.fetch_all(args.path)
    return

  def process_fetch(self, seqid, iprot, oprot):
    args = fetch_args()
    args.read(iprot)
    iprot.readMessageEnd()
    self._handler.fetch(args.path, args.name)
    return

  def process_merge(self, seqid, iprot, oprot):
    args = merge_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = merge_result()
    try:
      result.success = self._handler.merge(args.path, args.ref, args.msg, args.commit_msg, args.no_ff, args.env)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("merge", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_merge_tree(self, seqid, iprot, oprot):
    args = merge_tree_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = merge_tree_result()
    try:
      result.success = self._handler.merge_tree(args.path, args.ours, args.theirs)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("merge_tree", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_merge_head(self, seqid, iprot, oprot):
    args = merge_head_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = merge_head_result()
    try:
      result.success = self._handler.merge_head(args.path, args.ref)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("merge_head", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_merge_commits(self, seqid, iprot, oprot):
    args = merge_commits_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = merge_commits_result()
    try:
      result.success = self._handler.merge_commits(args.path, args.ours, args.theirs)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("merge_commits", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_push(self, seqid, iprot, oprot):
    args = push_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = push_result()
    try:
      result.success = self._handler.push(args.path, args.remote, args.ref, args.env)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("push", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_archive(self, seqid, iprot, oprot):
    args = archive_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = archive_result()
    try:
      result.success = self._handler.archive(args.path, args.prefix, args.ref)
    except ServiceUnavailable as unavailable:
      result.unavailable = unavailable
    except NoneResult as none_result:
      result.none_result = none_result
    oprot.writeMessageBegin("archive", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class get_args(object):
  """
  Attributes:
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
  )

  def __init__(self, path=None,):
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class get_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Repository, Repository.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Repository()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('get_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_branches_args(object):
  """
  Attributes:
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
  )

  def __init__(self, path=None,):
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_branches_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_branches_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype45, _size42) = iprot.readListBegin()
          for _i46 in xrange(_size42):
            _elem47 = iprot.readString();
            self.success.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_branches_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter48 in self.success:
        oprot.writeString(iter48)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_remotes_args(object):
  """
  Attributes:
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
  )

  def __init__(self, path=None,):
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_remotes_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_remotes_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype52, _size49) = iprot.readListBegin()
          for _i53 in xrange(_size49):
            _elem54 = iprot.readString();
            self.success.append(_elem54)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_remotes_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter55 in self.success:
        oprot.writeString(iter55)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_tags_args(object):
  """
  Attributes:
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
  )

  def __init__(self, path=None,):
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_tags_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_tags_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype59, _size56) = iprot.readListBegin()
          for _i60 in xrange(_size56):
            _elem61 = iprot.readString();
            self.success.append(_elem61)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_tags_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter62 in self.success:
        oprot.writeString(iter62)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class show_args(object):
  """
  Attributes:
   - path
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, path=None, ref=None,):
    self.path = path
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('show_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class show_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (GitObject, GitObject.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = GitObject()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('show_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ls_tree_args(object):
  """
  Attributes:
   - path
   - ref
   - req_path
   - recursive
   - with_size
   - with_commit
   - name_only
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.STRING, 'req_path', None, None, ), # 3
    (4, TType.BOOL, 'recursive', None, None, ), # 4
    (5, TType.BOOL, 'with_size', None, None, ), # 5
    (6, TType.BOOL, 'with_commit', None, None, ), # 6
    (7, TType.BOOL, 'name_only', None, None, ), # 7
  )

  def __init__(self, path=None, ref=None, req_path=None, recursive=None, with_size=None, with_commit=None, name_only=None,):
    self.path = path
    self.ref = ref
    self.req_path = req_path
    self.recursive = recursive
    self.with_size = with_size
    self.with_commit = with_commit
    self.name_only = name_only

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.req_path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.recursive = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.with_size = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.with_commit = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.name_only = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ls_tree_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.req_path is not None:
      oprot.writeFieldBegin('req_path', TType.STRING, 3)
      oprot.writeString(self.req_path)
      oprot.writeFieldEnd()
    if self.recursive is not None:
      oprot.writeFieldBegin('recursive', TType.BOOL, 4)
      oprot.writeBool(self.recursive)
      oprot.writeFieldEnd()
    if self.with_size is not None:
      oprot.writeFieldBegin('with_size', TType.BOOL, 5)
      oprot.writeBool(self.with_size)
      oprot.writeFieldEnd()
    if self.with_commit is not None:
      oprot.writeFieldBegin('with_commit', TType.BOOL, 6)
      oprot.writeBool(self.with_commit)
      oprot.writeFieldEnd()
    if self.name_only is not None:
      oprot.writeFieldBegin('name_only', TType.BOOL, 7)
      oprot.writeBool(self.name_only)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ls_tree_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ls_tree_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rev_list_args(object):
  """
  Attributes:
   - path
   - to_ref
   - from_ref
   - file_path
   - skip
   - max_count
   - author
   - query
   - first_parent
   - since
   - no_merges
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'to_ref', None, None, ), # 2
    (3, TType.STRING, 'from_ref', None, None, ), # 3
    (4, TType.STRING, 'file_path', None, None, ), # 4
    (5, TType.I32, 'skip', None, None, ), # 5
    (6, TType.I32, 'max_count', None, None, ), # 6
    (7, TType.STRING, 'author', None, None, ), # 7
    (8, TType.STRING, 'query', None, None, ), # 8
    (9, TType.BOOL, 'first_parent', None, None, ), # 9
    (10, TType.I64, 'since', None, None, ), # 10
    (11, TType.BOOL, 'no_merges', None, None, ), # 11
  )

  def __init__(self, path=None, to_ref=None, from_ref=None, file_path=None, skip=None, max_count=None, author=None, query=None, first_parent=None, since=None, no_merges=None,):
    self.path = path
    self.to_ref = to_ref
    self.from_ref = from_ref
    self.file_path = file_path
    self.skip = skip
    self.max_count = max_count
    self.author = author
    self.query = query
    self.first_parent = first_parent
    self.since = since
    self.no_merges = no_merges

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.to_ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.from_ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.file_path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.skip = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.max_count = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.author = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.query = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.first_parent = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.since = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.no_merges = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rev_list_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.to_ref is not None:
      oprot.writeFieldBegin('to_ref', TType.STRING, 2)
      oprot.writeString(self.to_ref)
      oprot.writeFieldEnd()
    if self.from_ref is not None:
      oprot.writeFieldBegin('from_ref', TType.STRING, 3)
      oprot.writeString(self.from_ref)
      oprot.writeFieldEnd()
    if self.file_path is not None:
      oprot.writeFieldBegin('file_path', TType.STRING, 4)
      oprot.writeString(self.file_path)
      oprot.writeFieldEnd()
    if self.skip is not None:
      oprot.writeFieldBegin('skip', TType.I32, 5)
      oprot.writeI32(self.skip)
      oprot.writeFieldEnd()
    if self.max_count is not None:
      oprot.writeFieldBegin('max_count', TType.I32, 6)
      oprot.writeI32(self.max_count)
      oprot.writeFieldEnd()
    if self.author is not None:
      oprot.writeFieldBegin('author', TType.STRING, 7)
      oprot.writeString(self.author)
      oprot.writeFieldEnd()
    if self.query is not None:
      oprot.writeFieldBegin('query', TType.STRING, 8)
      oprot.writeString(self.query)
      oprot.writeFieldEnd()
    if self.first_parent is not None:
      oprot.writeFieldBegin('first_parent', TType.BOOL, 9)
      oprot.writeBool(self.first_parent)
      oprot.writeFieldEnd()
    if self.since is not None:
      oprot.writeFieldBegin('since', TType.I64, 10)
      oprot.writeI64(self.since)
      oprot.writeFieldEnd()
    if self.no_merges is not None:
      oprot.writeFieldBegin('no_merges', TType.BOOL, 11)
      oprot.writeBool(self.no_merges)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class rev_list_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(Commit, Commit.thrift_spec)), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype66, _size63) = iprot.readListBegin()
          for _i67 in xrange(_size63):
            _elem68 = Commit()
            _elem68.read(iprot)
            self.success.append(_elem68)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('rev_list_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter69 in self.success:
        iter69.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class blame_args(object):
  """
  Attributes:
   - path
   - ref
   - req_path
   - lineno
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.STRING, 'req_path', None, None, ), # 3
    (4, TType.I32, 'lineno', None, None, ), # 4
  )

  def __init__(self, path=None, ref=None, req_path=None, lineno=None,):
    self.path = path
    self.ref = ref
    self.req_path = req_path
    self.lineno = lineno

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.req_path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.lineno = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('blame_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.req_path is not None:
      oprot.writeFieldBegin('req_path', TType.STRING, 3)
      oprot.writeString(self.req_path)
      oprot.writeFieldEnd()
    if self.lineno is not None:
      oprot.writeFieldBegin('lineno', TType.I32, 4)
      oprot.writeI32(self.lineno)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class blame_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Blame, Blame.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Blame()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('blame_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class format_patch_args(object):
  """
  Attributes:
   - path
   - ref
   - from_ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.STRING, 'from_ref', None, None, ), # 3
  )

  def __init__(self, path=None, ref=None, from_ref=None,):
    self.path = path
    self.ref = ref
    self.from_ref = from_ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.from_ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('format_patch_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.from_ref is not None:
      oprot.writeFieldBegin('from_ref', TType.STRING, 3)
      oprot.writeString(self.from_ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class format_patch_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('format_patch_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class detect_renamed_args(object):
  """
  Attributes:
   - path
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, path=None, ref=None,):
    self.path = path
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('detect_renamed_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class detect_renamed_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype71, _vtype72, _size70 ) = iprot.readMapBegin() 
          for _i74 in xrange(_size70):
            _key75 = iprot.readString();
            _val76 = iprot.readString();
            self.success[_key75] = _val76
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('detect_renamed_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter77,viter78 in self.success.items():
        oprot.writeString(kiter77)
        oprot.writeString(viter78)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class commit_args(object):
  """
  Attributes:
   - path
   - branch
   - parent_ref
   - author_name
   - author_email
   - message
   - reflog
   - data
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'branch', None, None, ), # 2
    (3, TType.STRING, 'parent_ref', None, None, ), # 3
    (4, TType.STRING, 'author_name', None, None, ), # 4
    (5, TType.STRING, 'author_email', None, None, ), # 5
    (6, TType.STRING, 'message', None, None, ), # 6
    (7, TType.STRING, 'reflog', None, None, ), # 7
    (8, TType.LIST, 'data', (TType.LIST,(TType.STRING,None)), None, ), # 8
  )

  def __init__(self, path=None, branch=None, parent_ref=None, author_name=None, author_email=None, message=None, reflog=None, data=None,):
    self.path = path
    self.branch = branch
    self.parent_ref = parent_ref
    self.author_name = author_name
    self.author_email = author_email
    self.message = message
    self.reflog = reflog
    self.data = data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.branch = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.parent_ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.author_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.author_email = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.message = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.reflog = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.data = []
          (_etype82, _size79) = iprot.readListBegin()
          for _i83 in xrange(_size79):
            _elem84 = []
            (_etype88, _size85) = iprot.readListBegin()
            for _i89 in xrange(_size85):
              _elem90 = iprot.readString();
              _elem84.append(_elem90)
            iprot.readListEnd()
            self.data.append(_elem84)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('commit_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.branch is not None:
      oprot.writeFieldBegin('branch', TType.STRING, 2)
      oprot.writeString(self.branch)
      oprot.writeFieldEnd()
    if self.parent_ref is not None:
      oprot.writeFieldBegin('parent_ref', TType.STRING, 3)
      oprot.writeString(self.parent_ref)
      oprot.writeFieldEnd()
    if self.author_name is not None:
      oprot.writeFieldBegin('author_name', TType.STRING, 4)
      oprot.writeString(self.author_name)
      oprot.writeFieldEnd()
    if self.author_email is not None:
      oprot.writeFieldBegin('author_email', TType.STRING, 5)
      oprot.writeString(self.author_email)
      oprot.writeFieldEnd()
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 6)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    if self.reflog is not None:
      oprot.writeFieldBegin('reflog', TType.STRING, 7)
      oprot.writeString(self.reflog)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.LIST, 8)
      oprot.writeListBegin(TType.LIST, len(self.data))
      for iter91 in self.data:
        oprot.writeListBegin(TType.STRING, len(iter91))
        for iter92 in iter91:
          oprot.writeString(iter92)
        oprot.writeListEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class commit_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('commit_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diff_args(object):
  """
  Attributes:
   - path
   - ref
   - from_ref
   - ignore_space
   - flags
   - context_lines
   - paths
   - rename_detection
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.STRING, 'from_ref', None, None, ), # 3
    (4, TType.BOOL, 'ignore_space', None, None, ), # 4
    (5, TType.I16, 'flags', None, None, ), # 5
    (6, TType.BOOL, 'context_lines', None, None, ), # 6
    (7, TType.LIST, 'paths', (TType.STRING,None), None, ), # 7
    (8, TType.BOOL, 'rename_detection', None, None, ), # 8
  )

  def __init__(self, path=None, ref=None, from_ref=None, ignore_space=None, flags=None, context_lines=None, paths=None, rename_detection=None,):
    self.path = path
    self.ref = ref
    self.from_ref = from_ref
    self.ignore_space = ignore_space
    self.flags = flags
    self.context_lines = context_lines
    self.paths = paths
    self.rename_detection = rename_detection

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.from_ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.ignore_space = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.flags = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.context_lines = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.paths = []
          (_etype96, _size93) = iprot.readListBegin()
          for _i97 in xrange(_size93):
            _elem98 = iprot.readString();
            self.paths.append(_elem98)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.rename_detection = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diff_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.from_ref is not None:
      oprot.writeFieldBegin('from_ref', TType.STRING, 3)
      oprot.writeString(self.from_ref)
      oprot.writeFieldEnd()
    if self.ignore_space is not None:
      oprot.writeFieldBegin('ignore_space', TType.BOOL, 4)
      oprot.writeBool(self.ignore_space)
      oprot.writeFieldEnd()
    if self.flags is not None:
      oprot.writeFieldBegin('flags', TType.I16, 5)
      oprot.writeI16(self.flags)
      oprot.writeFieldEnd()
    if self.context_lines is not None:
      oprot.writeFieldBegin('context_lines', TType.BOOL, 6)
      oprot.writeBool(self.context_lines)
      oprot.writeFieldEnd()
    if self.paths is not None:
      oprot.writeFieldBegin('paths', TType.LIST, 7)
      oprot.writeListBegin(TType.STRING, len(self.paths))
      for iter99 in self.paths:
        oprot.writeString(iter99)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.rename_detection is not None:
      oprot.writeFieldBegin('rename_detection', TType.BOOL, 8)
      oprot.writeBool(self.rename_detection)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class diff_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Diff, Diff.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Diff()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('diff_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class resolve_commit_args(object):
  """
  Attributes:
   - path
   - version
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'version', None, None, ), # 2
  )

  def __init__(self, path=None, version=None,):
    self.path = path
    self.version = version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.version = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resolve_commit_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.STRING, 2)
      oprot.writeString(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class resolve_commit_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resolve_commit_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class resolve_type_args(object):
  """
  Attributes:
   - path
   - version
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'version', None, None, ), # 2
  )

  def __init__(self, path=None, version=None,):
    self.path = path
    self.version = version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.version = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resolve_type_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.STRING, 2)
      oprot.writeString(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class resolve_type_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('resolve_type_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_branch_args(object):
  """
  Attributes:
   - path
   - name
   - ref
   - force
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.STRING, 'ref', None, None, ), # 3
    (4, TType.BOOL, 'force', None, None, ), # 4
  )

  def __init__(self, path=None, name=None, ref=None, force=None,):
    self.path = path
    self.name = name
    self.ref = ref
    self.force = force

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.force = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_branch_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 3)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.force is not None:
      oprot.writeFieldBegin('force', TType.BOOL, 4)
      oprot.writeBool(self.force)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class create_branch_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('create_branch_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_branch_args(object):
  """
  Attributes:
   - path
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
  )

  def __init__(self, path=None, name=None,):
    self.path = path
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_branch_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class delete_branch_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('delete_branch_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clone_to_args(object):
  """
  Attributes:
   - path
   - to_path
   - is_bare
   - branch
   - is_mirror
   - env
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'to_path', None, None, ), # 2
    (3, TType.BOOL, 'is_bare', None, None, ), # 3
    (4, TType.STRING, 'branch', None, None, ), # 4
    (5, TType.BOOL, 'is_mirror', None, None, ), # 5
    (6, TType.MAP, 'env', (TType.STRING,None,TType.STRING,None), None, ), # 6
  )

  def __init__(self, path=None, to_path=None, is_bare=None, branch=None, is_mirror=None, env=None,):
    self.path = path
    self.to_path = to_path
    self.is_bare = is_bare
    self.branch = branch
    self.is_mirror = is_mirror
    self.env = env

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.to_path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_bare = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.branch = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.is_mirror = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.env = {}
          (_ktype101, _vtype102, _size100 ) = iprot.readMapBegin() 
          for _i104 in xrange(_size100):
            _key105 = iprot.readString();
            _val106 = iprot.readString();
            self.env[_key105] = _val106
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clone_to_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.to_path is not None:
      oprot.writeFieldBegin('to_path', TType.STRING, 2)
      oprot.writeString(self.to_path)
      oprot.writeFieldEnd()
    if self.is_bare is not None:
      oprot.writeFieldBegin('is_bare', TType.BOOL, 3)
      oprot.writeBool(self.is_bare)
      oprot.writeFieldEnd()
    if self.branch is not None:
      oprot.writeFieldBegin('branch', TType.STRING, 4)
      oprot.writeString(self.branch)
      oprot.writeFieldEnd()
    if self.is_mirror is not None:
      oprot.writeFieldBegin('is_mirror', TType.BOOL, 5)
      oprot.writeBool(self.is_mirror)
      oprot.writeFieldEnd()
    if self.env is not None:
      oprot.writeFieldBegin('env', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.env))
      for kiter107,viter108 in self.env.items():
        oprot.writeString(kiter107)
        oprot.writeString(viter108)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class clone_to_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Repository, Repository.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Repository()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('clone_to_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mirror_args(object):
  """
  Attributes:
   - url
   - to_path
   - is_bare
   - branch
   - env
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'url', None, None, ), # 1
    (2, TType.STRING, 'to_path', None, None, ), # 2
    (3, TType.BOOL, 'is_bare', None, None, ), # 3
    (4, TType.STRING, 'branch', None, None, ), # 4
    (5, TType.MAP, 'env', (TType.STRING,None,TType.STRING,None), None, ), # 5
  )

  def __init__(self, url=None, to_path=None, is_bare=None, branch=None, env=None,):
    self.url = url
    self.to_path = to_path
    self.is_bare = is_bare
    self.branch = branch
    self.env = env

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.to_path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_bare = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.branch = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.env = {}
          (_ktype110, _vtype111, _size109 ) = iprot.readMapBegin() 
          for _i113 in xrange(_size109):
            _key114 = iprot.readString();
            _val115 = iprot.readString();
            self.env[_key114] = _val115
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mirror_args')
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 1)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.to_path is not None:
      oprot.writeFieldBegin('to_path', TType.STRING, 2)
      oprot.writeString(self.to_path)
      oprot.writeFieldEnd()
    if self.is_bare is not None:
      oprot.writeFieldBegin('is_bare', TType.BOOL, 3)
      oprot.writeBool(self.is_bare)
      oprot.writeFieldEnd()
    if self.branch is not None:
      oprot.writeFieldBegin('branch', TType.STRING, 4)
      oprot.writeString(self.branch)
      oprot.writeFieldEnd()
    if self.env is not None:
      oprot.writeFieldBegin('env', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.env))
      for kiter116,viter117 in self.env.items():
        oprot.writeString(kiter116)
        oprot.writeString(viter117)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class mirror_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Repository, Repository.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Repository()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('mirror_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class init_args(object):
  """
  Attributes:
   - to_path
   - work_path
   - is_bare
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'to_path', None, None, ), # 1
    (2, TType.STRING, 'work_path', None, None, ), # 2
    (3, TType.BOOL, 'is_bare', None, None, ), # 3
  )

  def __init__(self, to_path=None, work_path=None, is_bare=None,):
    self.to_path = to_path
    self.work_path = work_path
    self.is_bare = is_bare

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.to_path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.work_path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.is_bare = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('init_args')
    if self.to_path is not None:
      oprot.writeFieldBegin('to_path', TType.STRING, 1)
      oprot.writeString(self.to_path)
      oprot.writeFieldEnd()
    if self.work_path is not None:
      oprot.writeFieldBegin('work_path', TType.STRING, 2)
      oprot.writeString(self.work_path)
      oprot.writeFieldEnd()
    if self.is_bare is not None:
      oprot.writeFieldBegin('is_bare', TType.BOOL, 3)
      oprot.writeBool(self.is_bare)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class init_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Repository, Repository.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Repository()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('init_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_references_args(object):
  """
  Attributes:
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
  )

  def __init__(self, path=None,):
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_references_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class list_references_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype121, _size118) = iprot.readListBegin()
          for _i122 in xrange(_size118):
            _elem123 = iprot.readString();
            self.success.append(_elem123)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('list_references_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter124 in self.success:
        oprot.writeString(iter124)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_remote_args(object):
  """
  Attributes:
   - path
   - name
   - url
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.STRING, 'url', None, None, ), # 3
  )

  def __init__(self, path=None, name=None, url=None,):
    self.path = path
    self.name = name
    self.url = url

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_remote_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 3)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class add_remote_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('add_remote_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_ref_args(object):
  """
  Attributes:
   - path
   - ref
   - newvalue
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.STRING, 'newvalue', None, None, ), # 3
  )

  def __init__(self, path=None, ref=None, newvalue=None,):
    self.path = path
    self.ref = ref
    self.newvalue = newvalue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.newvalue = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_ref_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.newvalue is not None:
      oprot.writeFieldBegin('newvalue', TType.STRING, 3)
      oprot.writeString(self.newvalue)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_ref_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_ref_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_head_args(object):
  """
  Attributes:
   - path
   - branch_name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'branch_name', None, None, ), # 2
  )

  def __init__(self, path=None, branch_name=None,):
    self.path = path
    self.branch_name = branch_name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.branch_name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_head_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.branch_name is not None:
      oprot.writeFieldBegin('branch_name', TType.STRING, 2)
      oprot.writeString(self.branch_name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class update_head_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('update_head_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sha_args(object):
  """
  Attributes:
   - path
   - rev
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'rev', None, None, ), # 2
  )

  def __init__(self, path=None, rev=None,):
    self.path = path
    self.rev = rev

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.rev = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sha_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.rev is not None:
      oprot.writeFieldBegin('rev', TType.STRING, 2)
      oprot.writeString(self.rev)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class sha_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('sha_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class merge_base_args(object):
  """
  Attributes:
   - path
   - to_sha
   - from_sha
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'to_sha', None, None, ), # 2
    (3, TType.STRING, 'from_sha', None, None, ), # 3
  )

  def __init__(self, path=None, to_sha=None, from_sha=None,):
    self.path = path
    self.to_sha = to_sha
    self.from_sha = from_sha

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.to_sha = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.from_sha = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('merge_base_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.to_sha is not None:
      oprot.writeFieldBegin('to_sha', TType.STRING, 2)
      oprot.writeString(self.to_sha)
      oprot.writeFieldEnd()
    if self.from_sha is not None:
      oprot.writeFieldBegin('from_sha', TType.STRING, 3)
      oprot.writeString(self.from_sha)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class merge_base_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('merge_base_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class fetch_all_args(object):
  """
  Attributes:
   - path
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
  )

  def __init__(self, path=None,):
    self.path = path

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('fetch_all_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class fetch_args(object):
  """
  Attributes:
   - path
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
  )

  def __init__(self, path=None, name=None,):
    self.path = path
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('fetch_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class merge_args(object):
  """
  Attributes:
   - path
   - ref
   - msg
   - commit_msg
   - no_ff
   - env
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
    (3, TType.STRING, 'msg', None, None, ), # 3
    (4, TType.STRING, 'commit_msg', None, None, ), # 4
    (5, TType.BOOL, 'no_ff', None, None, ), # 5
    (6, TType.MAP, 'env', (TType.STRING,None,TType.STRING,None), None, ), # 6
  )

  def __init__(self, path=None, ref=None, msg=None, commit_msg=None, no_ff=None, env=None,):
    self.path = path
    self.ref = ref
    self.msg = msg
    self.commit_msg = commit_msg
    self.no_ff = no_ff
    self.env = env

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.msg = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.commit_msg = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.no_ff = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.env = {}
          (_ktype126, _vtype127, _size125 ) = iprot.readMapBegin() 
          for _i129 in xrange(_size125):
            _key130 = iprot.readString();
            _val131 = iprot.readString();
            self.env[_key130] = _val131
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('merge_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.msg is not None:
      oprot.writeFieldBegin('msg', TType.STRING, 3)
      oprot.writeString(self.msg)
      oprot.writeFieldEnd()
    if self.commit_msg is not None:
      oprot.writeFieldBegin('commit_msg', TType.STRING, 4)
      oprot.writeString(self.commit_msg)
      oprot.writeFieldEnd()
    if self.no_ff is not None:
      oprot.writeFieldBegin('no_ff', TType.BOOL, 5)
      oprot.writeBool(self.no_ff)
      oprot.writeFieldEnd()
    if self.env is not None:
      oprot.writeFieldBegin('env', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.env))
      for kiter132,viter133 in self.env.items():
        oprot.writeString(kiter132)
        oprot.writeString(viter133)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class merge_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ProcessResult, ProcessResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ProcessResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('merge_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class merge_tree_args(object):
  """
  Attributes:
   - path
   - ours
   - theirs
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'ours', None, None, ), # 2
    (3, TType.STRING, 'theirs', None, None, ), # 3
  )

  def __init__(self, path=None, ours=None, theirs=None,):
    self.path = path
    self.ours = ours
    self.theirs = theirs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ours = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.theirs = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('merge_tree_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.ours is not None:
      oprot.writeFieldBegin('ours', TType.STRING, 2)
      oprot.writeString(self.ours)
      oprot.writeFieldEnd()
    if self.theirs is not None:
      oprot.writeFieldBegin('theirs', TType.STRING, 3)
      oprot.writeString(self.theirs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class merge_tree_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (MergeIndex, MergeIndex.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = MergeIndex()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('merge_tree_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class merge_head_args(object):
  """
  Attributes:
   - path
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'ref', None, None, ), # 2
  )

  def __init__(self, path=None, ref=None,):
    self.path = path
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('merge_head_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 2)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class merge_head_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (MergeResult, MergeResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = MergeResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('merge_head_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class merge_commits_args(object):
  """
  Attributes:
   - path
   - ours
   - theirs
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'ours', None, None, ), # 2
    (3, TType.STRING, 'theirs', None, None, ), # 3
  )

  def __init__(self, path=None, ours=None, theirs=None,):
    self.path = path
    self.ours = ours
    self.theirs = theirs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ours = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.theirs = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('merge_commits_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.ours is not None:
      oprot.writeFieldBegin('ours', TType.STRING, 2)
      oprot.writeString(self.ours)
      oprot.writeFieldEnd()
    if self.theirs is not None:
      oprot.writeFieldBegin('theirs', TType.STRING, 3)
      oprot.writeString(self.theirs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class merge_commits_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (MergeIndex, MergeIndex.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = MergeIndex()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('merge_commits_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class push_args(object):
  """
  Attributes:
   - path
   - remote
   - ref
   - env
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'remote', None, None, ), # 2
    (3, TType.STRING, 'ref', None, None, ), # 3
    (4, TType.MAP, 'env', (TType.STRING,None,TType.STRING,None), None, ), # 4
  )

  def __init__(self, path=None, remote=None, ref=None, env=None,):
    self.path = path
    self.remote = remote
    self.ref = ref
    self.env = env

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.remote = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.env = {}
          (_ktype135, _vtype136, _size134 ) = iprot.readMapBegin() 
          for _i138 in xrange(_size134):
            _key139 = iprot.readString();
            _val140 = iprot.readString();
            self.env[_key139] = _val140
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('push_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.remote is not None:
      oprot.writeFieldBegin('remote', TType.STRING, 2)
      oprot.writeString(self.remote)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 3)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    if self.env is not None:
      oprot.writeFieldBegin('env', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.env))
      for kiter141,viter142 in self.env.items():
        oprot.writeString(kiter141)
        oprot.writeString(viter142)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class push_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (ProcessResult, ProcessResult.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = ProcessResult()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('push_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class archive_args(object):
  """
  Attributes:
   - path
   - prefix
   - ref
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'path', None, None, ), # 1
    (2, TType.STRING, 'prefix', None, None, ), # 2
    (3, TType.STRING, 'ref', None, None, ), # 3
  )

  def __init__(self, path=None, prefix=None, ref=None,):
    self.path = path
    self.prefix = prefix
    self.ref = ref

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.prefix = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.ref = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('archive_args')
    if self.path is not None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path)
      oprot.writeFieldEnd()
    if self.prefix is not None:
      oprot.writeFieldBegin('prefix', TType.STRING, 2)
      oprot.writeString(self.prefix)
      oprot.writeFieldEnd()
    if self.ref is not None:
      oprot.writeFieldBegin('ref', TType.STRING, 3)
      oprot.writeString(self.ref)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class archive_result(object):
  """
  Attributes:
   - success
   - unavailable
   - none_result
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
    (1, TType.STRUCT, 'unavailable', (ServiceUnavailable, ServiceUnavailable.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'none_result', (NoneResult, NoneResult.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, unavailable=None, none_result=None,):
    self.success = success
    self.unavailable = unavailable
    self.none_result = none_result

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.unavailable = ServiceUnavailable()
          self.unavailable.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.none_result = NoneResult()
          self.none_result.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    self.validate()
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('archive_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    if self.unavailable is not None:
      oprot.writeFieldBegin('unavailable', TType.STRUCT, 1)
      self.unavailable.write(oprot)
      oprot.writeFieldEnd()
    if self.none_result is not None:
      oprot.writeFieldBegin('none_result', TType.STRUCT, 2)
      self.none_result.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
